[{"title":"Cookie Session Token","date":"2017-09-19T06:44:38.000Z","path":"2017/09/19/Session-Cookie-Token/","text":"博客又被扔在一旁小半年了，干脆立个flag好了，11月之前一周一更？把之前学习的内容做个总结归纳。 Cookie Session Token前言众所周知，目前客户端与服务端之间的交互基本都是基于Http和Https，它们本身是无状态的，只负责对应的请求和相应，那么当一个请求从客户端发送到服务端的时候，服务端无法知道是谁发出的请求，也就不知道把什么资源返回到客户端，这时我们就需要用到以上信息来记录用户的状态。 CookieCookie实际上是一小段的文本信息，当客户端首次发起请求时，服务端会生成一个Cookie并返回给客户端，Cookie存储在客户端，在下次请求发起时，请求内容连同Cookie一起提交给服务端，服务端通过该Cookie来判别该用户信息。 SessionSession同样是客户端在首次请求时创建的，不过此时服务端并不是把所有信息全都返回给客户端，而是将用户信息存储在服务端并将对应的SessionId返回给客户端，通常客户端会将这个SessionId存放在Cookie中，之后客户端的每次请求只需要带上相应的SessionId即可。使用Session的最大问题在于单点登录，用户的Session只会存在于一台服务器上，如果要实现单点登录，这就要求在各个服务器上同步Session，开销过大 Token相比于传统的身份验证方式，Token在扩展性和安全性方面的优势，使其十分适用于Web应用和移动应用上。 1、客户端将用户自己的用户名密码传到服务端，这一过程一般是HTTP POST请求，建议的方式是通过SSL传输加密(https)，避免敏感信息被嗅探。2、服务端核对用户名密码，success后将用户userId作为一个属性与其头部分别进行Base64编码后形成签名，形成一个JWT(JSON Web Token)，将JWT作为Cookie一部分返回客户端，之后客户端请求带上JWT，服务端进行Base64解码就可以获取到用户的userId","tags":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/tags/技术/"}]},{"title":"GIT","date":"2017-05-26T08:44:29.000Z","path":"2017/05/26/浅谈git/","text":"博客搭建好已有小半年，由于自己实在唠叨不起来，所以迟迟不敢动笔。前几篇博客先把自己在bear上的笔记优化重构一下吧。 git基础命令git loggit log 查看历史commit记录 git rmgit rm test.java 从git仓库删除test.java文件，同时删除本地文件git rm -cache test.java 从git仓库删除test.java文件，不删除本地文件 git pullgit pull [remote-name] [branch-name] 获取远程服务器数据，并同时与本地数据合并（可能会出现冲突） git pushgit push [remote-name] [branch-name]上传数据到远程分支，若出现冲突，则上传失败git push -force [remote-name] [branch-name]强制上传数据到远程分支（覆盖远程数据，慎用！！！） git branchgit branch 查看本地分支列表git branch -r 查看原创分支列表git branch -a 查看所有分支git branch -d [branch-name] 删除指定分支git branch -D [branch-name] 强制删除指定分支git push origin:[remote-branch] 删除指定远程分支 git checkoutgit checkout [branch-name] 切换到指定分支（切换前需要先commit或stash）git checkout -b [new-branch-name] 基于当前分支创建一个新分支git checkout -b [branch-name] origin/[branch-name] 获取远程分支到本地git checkout [file-name] 获取远程最新文件git checkout –. 放弃本地所有modify文件改动 add romote branch1.git checkout [branch-name] 切换到要上传的分支2.git remote add origin [branch-name] 添加远程分支。3.git push origin [branch-name] 推送数据到远程分支(自动创建分支，step2可省去) git合并分支（推荐cherry-pick）git merge1.git merge [branch-name] 合并指定分支到当前分支2.git add -A 手动解决冲突后，暂时缓存3.git commit -m “feat:新增XXX功能” 再次提交 git cherry-pickgit cherry-pick commit -[id] 合并指定commit到当前分支git add -A 手动解决冲突后暂时缓存git cherry-pick – continue 继续刚才的pick操作git cherry-pick – abort 放弃cherry-pick操作 git撤销与修改git resetgit reset –mixed commit-id 默认方式，回退到指定个版本，只保留源码，回退commit和index信息git reset –soft commit-id 回退到某个版本，只回退了commit的信息，不会恢复到index file级。如果还要提交，直接commit即可git reset –hard commit-id #彻底回退到某个版本，本地的源码也会变为上一个版本的内容 结束","tags":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/tags/技术/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"}]},{"title":"Hello World","date":"2017-01-13T07:11:03.000Z","path":"2017/01/13/hello/","text":"Hello World 终于有个地方可以扯扯技术，说说当下，念念往事，想想未来写在这里就是为了让年轻时候吹过的逼，有据可查","tags":[]}]