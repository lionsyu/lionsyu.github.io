[{"title":"优雅的实现获取token，并转换成服务端userId","date":"2018-05-03T08:39:04.000Z","path":"2018/05/03/优雅的实现获取token，并转换成服务端userId/","text":"在跟客户端（尤其是APP）交互的过程中，由于http的无状态性，就需要定义token来鉴别用户身份。而对于服务端来讲，用户信息基本采用userId的形式进行对应，以此简单的写一个利用spring拦截器将token转换为userId的方法 1、首先自定义注解(在需要token转userId的方法上加上该注解即可) 1234@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface AccessToken &#123;&#125; 2、定义AccessToken方法里的内容，其中用户token我是存在redis中，用stringRedisTemplate来获取token对应的userId，对于没有获取到token的请求，返回401，让客户端直接跳转到登录页面 12345678910111213141516171819202122232425262728293031323334@Componentpublic class AccessTokenInterceptor extends HandlerInterceptorAdapter &#123; @Autowired StringRedisTemplate stringRedisTemplate; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; if (!(handler instanceof HandlerMethod)) &#123; return true; &#125; HandlerMethod handlerMethod = (HandlerMethod) handler; Method method = handlerMethod.getMethod(); //未使用accessToken if (method.getAnnotation(AccessToken.class) == null) &#123; return true; &#125; //从header中获取token String token = request.getHeader(TOKEN); if (!StringUtils.isEmpty(token)) &#123; String userId = stringRedisTemplate.opsForValue().get(token); if (!StringUtils.isEmpty(userId)) &#123; request.setAttribute(CURRENT_USER_ID, Long.valueOf(userId)); return true; &#125; &#125; response.setStatus(HttpServletResponse.SC_UNAUTHORIZED); return false; &#125;&#125; 3、最后在需要的方法中加上accessToken注解即可 12345678@ApiOperation(value = \"测试\") @ApiImplicitParam(name = TOKEN, value = \"用户token\", required = true, paramType = \"header\") @AccessToken @GetMapping(\"/test\") public ResponseResult collection(HttpServletRequest request) &#123; Long userId = (Long) request.getAttribute(CURRENT_USER_ID); System.out.println(userId); &#125; 如此服务端便知道这个请求是哪个用户发起的了，在最后的controller中使用了swagger2生成接口文档，使用swagger2的好处是不用在单独维护接口文档，并且通过swagger-ui提供的页面可以让客户端与服务端直接模拟请求。关于swagger部分的内容会在之后的博客中写到。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"RESTful API 基础知识","date":"2018-02-01T06:44:38.000Z","path":"2018/02/01/RESTful/","text":"1年的事情也陆陆续续忙完了，今天难得空闲，随便整理些最近的笔记 RESTful API 基础知识常用Http动词GET (选择)：从服务器上获取一个具体的资源或者一个资源列表。POST （创建）： 在服务器上创建一个新的资源。PUT （更新）：以整体的方式更新服务器上的一个资源。PATCH （更新）：只更新服务器上一个资源的一个属性。DELETE （删除）：删除服务器上的一个资源。 服务端返回状态码1xx范围的状态码是保留给底层HTTP功能使用的，并且估计在你的职业生涯里面也用不着手动发送这样一个状态码出来。 2xx范围的状态码是保留给成功消息使用的，你尽可能的确保服务器总发送这些状态码给用户。 3xx范围的状态码是保留给重定向用的。大多数的API不会太常使用这类状态码，但是在新的超媒体样式的API中会使用更多一些。 4xx范围的状态码是保留给客户端错误用的。例如，客户端提供了一些错误的数据或请求了不存在的内容。这些请求应该是幂等的，不会改变任何服务器的状态。 5xx范围的状态码是保留给服务器端错误用的。这些错误常常是从底层的函数抛出来的，并且开发人员也通常没法处理。发送这类状态码的目的是确保客户端能得到一些响应。收到5xx响应后，客户端没办法知道服务器端的状态，所以这类状态码是要尽可能的避免。 规范url使用名词而不是动词,且使用复数名词Get方法和查询参数不应该涉及状态改变使用Http状态码处理错误版本化你的API为集合提供过滤 排序 选择和分页等功能过滤 GET /cars?color=red 返回红色的cars排序 GET /cars?sort=-manufactorer,+model选择 GET /cars?fields=manufacturer,model,id,color分页 GET /cars?offset=10&amp;limit=5 使用子资源表达关系GET /cars/711/drivers/ 返回 car 711的所有司机GET /cars/711/drivers/4 返回 car 711的4号司机","tags":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/tags/技术/"}]},{"title":"GIT","date":"2017-05-26T08:44:29.000Z","path":"2017/05/26/浅谈git/","text":"博客搭建好已有小半年，由于自己实在唠叨不起来，所以迟迟不敢动笔。前几篇博客先把自己在bear上的笔记优化重构一下吧。 git基础命令git loggit log 查看历史commit记录 git rmgit rm test.java 从git仓库删除test.java文件，同时删除本地文件git rm -cache test.java 从git仓库删除test.java文件，不删除本地文件 git pullgit pull [remote-name] [branch-name] 获取远程服务器数据，并同时与本地数据合并（可能会出现冲突） git pushgit push [remote-name] [branch-name]上传数据到远程分支，若出现冲突，则上传失败git push -force [remote-name] [branch-name]强制上传数据到远程分支（覆盖远程数据，慎用！！！） git branchgit branch 查看本地分支列表git branch -r 查看远程分支列表git branch -a 查看所有分支git branch -d [branch-name] 删除指定分支git branch -D [branch-name] 强制删除指定分支git push origin:[remote-branch] 删除指定远程分支 git checkoutgit checkout [branch-name] 切换到指定分支（切换前需要先commit或stash）git checkout -b [new-branch-name] 基于当前分支创建一个新分支git checkout -b [branch-name] origin/[branch-name] 获取远程分支到本地git checkout [file-name] 获取远程最新文件git checkout –. 放弃本地所有modify文件改动 add romote branch1.git checkout [branch-name] 切换到要上传的分支2.git remote add origin [branch-name] 添加远程分支。3.git push origin [branch-name] 推送数据到远程分支(自动创建分支，step2可省去) git stashgit stash 将工作区内容暂存git stash apply恢复工作区内容 但是不删除stash信息，通过git stash drop来删除git stash pop 恢复工作区，并且删除stash信息 git合并分支（推荐cherry-pick）git merge1.git merge [branch-name] 合并指定分支到当前分支2.git add -A 手动解决冲突后，暂时缓存3.git commit -m “feat:新增XXX功能” 再次提交 git cherry-pickgit cherry-pick commit -[id] 合并指定commit到当前分支git add -A 手动解决冲突后暂时缓存git cherry-pick – continue 继续刚才的pick操作git cherry-pick – abort 放弃cherry-pick操作 git撤销与修改git resetgit reset –mixed [commit-id] 默认方式，回退到指定个版本，只保留源码，回退commit和index信息git reset –soft [commit-id] 回退到某个版本，只回退了commit的信息，不会恢复到index file级。如果还要提交，直接commit即可git reset –hard [commit-id] #彻底回退到某个版本，本地的源码也会变为上一个版本的内容git reset –hard HEAD^ 回退到上一个版本 结束","tags":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/tags/技术/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"}]},{"title":"Hello World","date":"2017-01-13T07:11:03.000Z","path":"2017/01/13/hello/","text":"Hello World 终于有个地方可以扯扯技术，说说当下，念念往事，想想未来写在这里就是为了让年轻时候吹过的逼，有据可查","tags":[]}]